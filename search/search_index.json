{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CryptoPi: Built for Crypto. Powered by Intelligence.","text":"<p>CryptoPi is a Python library tailored for the UM Hackathon 2025 \u2013 Balaena Quant Challenge (Domain 2). Our solution directly addresses the challenge of building robust alpha-generating trading strategies using Machine Learning (ML) on on-chain crypto data.</p> <p>Explore the full documentation here to get started.</p>"},{"location":"#problem-statement","title":"Problem Statement","text":"<p>Traditional backtesting frameworks fall short in the evolving landscape of crypto trading, constraining alpha generation.</p>"},{"location":"#pain-points","title":"Pain Points \ud83d\udea8","text":"<ol> <li>Lack of ML Integration: Most existing backtesting frameworks are not designed with machine learning in mind. Integrating ML pipelines\u2014such as sentiment models, Hidden semi-Markov Models (HSMMs), or transformers\u2014requires cumbersome custom code. This lack of native support discourages data-driven strategies and limits the potential for intelligent signal generation.</li> <li>Slow Performance on Large Datasets: Frameworks like Backtrader, while powerful, are often bottlenecked by Python\u2019s single-threaded performance. Running simulations on high-frequency or long-term historical datasets can become painfully slow, especially when testing multiple strategies or models in parallel.</li> <li>Lack of Experiment Tracking and Reproducibility: Backtest results are difficult to reproduce without manual logging and versioning. There is no standardized way to track which data, models, or parameters were used, making it hard to validate findings or roll back to previous experiments. This severely impacts research transparency and credibility.</li> </ol>"},{"location":"#proposed-solution","title":"Proposed Solution","text":"<p>We propose a model-centric backtesting library built for the crypto domain, creating data-driven, adaptive trading strategies that better reflect the complexities of the crypto market.</p>"},{"location":"#unique-selling-points","title":"Unique Selling Points \ud83d\ude80","text":"<ol> <li>ML-Native Design: CryptoPi natively supports the seamless integration of machine learning models, including sentiment analysis, HMMs, and deep learning architectures. This allows researchers and quant developers to focus on building data-driven strategies instead of wrestling with incompatible toolchains. Our modular design encourages experimentation, enabling strategies to be discovered rather than hardcoded.</li> <li>Smart Caching Layer: CryptoPi implements a smart caching mechanism that stores intermediate results such as preprocessed datasets, extracted features, and model outputs. This dramatically reduces redundant computation, allowing faster experimentation by reusing previously computed results for similar runs or parameter sets.</li> <li>Versioning &amp; Reproducibility: Every backtest run in CryptoPi is automatically versioned. This includes metadata such as dataset versions, model parameters, strategy configurations, and performance metrics. It ensures that experiments are transparent, traceable, and fully reproducible\u2014crucial for maintaining research integrity and enabling enterprise-grade auditability.</li> </ol>"},{"location":"#model-selections","title":"Model Selections","text":"<ol> <li> <p>Regime Detection Model - Hidden Markov Model (HMM): The HMM was selected for its strengths in modeling temporal patterns in market behavior:</p> </li> <li> <p>\ud83d\udd0d Captures Hidden Market States: Effectively identifies latent regimes such as bull, bear, or sideways trends.</p> </li> <li>\ud83c\udfb2 Probabilistic Transitions: Models regime shifts with realistic probabilities, useful for dynamic environments.</li> <li> <p>\ud83e\udeb6 Lightweight &amp; Efficient: Offers a favorable trade-off between computational cost and accuracy, suitable for scalable or resource-constrained pipelines.</p> </li> <li> <p>Alpha Model - Logistic Regression: Logistic Regression was chosen for its balance of simplicity, speed, and reliability:</p> </li> <li> <p>\ud83d\udd10 Robust with Limited Data: Performs well even with smaller datasets, avoiding overfitting.</p> </li> <li>\ud83d\udcca Probabilistic Outputs: Generates interpretable signal confidence levels to guide position sizing.</li> <li>\ud83d\udd0d Interpretability: Clear feature importance makes it easier to audit and refine strategies.</li> <li>\u26a1 Fast Inference Time: Low latency makes it ideal for real-time trade signal generation.</li> </ol>"},{"location":"#impacts","title":"Impacts","text":"<ol> <li>\u26a1 Accelerated Strategy Development: By streamlining the integration of machine learning and automating key components of the backtesting process, CryptoPi helps users avoid the traditional trial-and-error approach to strategy design. This reduces development time while encouraging creativity and innovation in discovering effective trading strategies.</li> <li>\ud83c\udf0d Increased Accessibility: CryptoPi lowers the barrier to entry for algorithmic trading. With intuitive visualizations, a modular plug-and-play design, and support for pretrained models, even users without deep coding expertise can explore, test, and understand sophisticated strategies.</li> <li>\ud83d\udcca Data-Driven Decision Making: CryptoPi promotes confidence through data. By providing transparent and reproducible metrics on strategy performance, users can rely on clear, quantitative insights instead of gut feelings\u2014ultimately reducing emotional or impulsive trading decisions.</li> </ol>"},{"location":"#model-performance","title":"Model Performance","text":"<ol> <li>Sharpe Ratio (SR) &gt;= 1.8</li> </ol> <p>Indicates strong risk-adjusted returns, suggesting the strategy generates significantly more return per unit of volatility than a passive benchmark.</p> <ol> <li>Max Drawdown (MDD) &gt; -30%</li> </ol> <p>Maintains capital preservation with acceptable downside risk, ensuring the strategy avoids catastrophic losses during adverse market conditions.</p> <ol> <li>Trade Frequency &gt;= 3%</li> </ol> <p>Balances between overtrading and undertrading by maintaining a healthy level of trading activity, enabling sufficient market participation without excessive noise.</p>"},{"location":"#future-improvements","title":"Future Improvements","text":"<ol> <li>\ud83d\udfe2 Live Trading &amp; Real-Time Simulation: Integrate real-time market data and execute strategies live, with support for simulation in fast-forward mode. This will bridge the gap between research and deployment.</li> <li>\u2699\ufe0f Model Enhancement &amp; Finetuning: Upgrade models to more advanced architectures and apply dynamic finetuning strategies for improved signal accuracy and robustness.</li> <li>\ud83e\udde0 Multi-Modal Fusion: Combine sentiment, technical, fundamental, and on-chain data using advanced fusion techniques to capture richer market insights.</li> <li>\ud83d\udcca Data &amp; Feature Engineering: Engineer more alpha-rich features and apply real-time pipelines to adapt quickly to changing market conditions.</li> </ol>"},{"location":"#our-team-6thsense","title":"Our Team: 6thSense","text":"Name Role Ng Khai Hon Project Manager Chong Boon Ping ML Engineer Tneoh Chuan Lin Backend Engineer Poh Sharon Data Engineer Vanessa Jing Taing Product Manager"},{"location":"alpha/","title":"AlphaModel","text":""},{"location":"alpha/#alpha-model","title":"Alpha Model","text":"<p>This module provides a unified interface for training and evaluating machine learning models, including a Transformer-based deep learning model for sequential data and an XGBoost model for tabular data.</p>"},{"location":"alpha/#basemodel","title":"BaseModel","text":"<p>Abstract base class to enforce a consistent interface across all models. All model classes should inherit from BaseModel.</p>"},{"location":"alpha/#transformermodel","title":"TransformerModel","text":"<p>This is a PyTorch-based Transformer model designed for time series or sequential data. The model processes input sequences using self-attention mechanisms and is trained to perform binary classification.</p>"},{"location":"alpha/#parameters","title":"Parameters","text":"Parameter Type Description input_dim int Number of features in each time step. seq_len int Sequence length expected per sample. d_model int Dimension of the Transformer model. nhead int Number of attention heads. num_layers int Number of Transformer encoder layers. dropout float Dropout rate. lr float Learning rate for the optimizer. epochs int Number of training epochs. batch_size int Batch size for training. device str Device to train on ('cuda' or 'cpu'). checkpoint_path str File path for saving/loading model checkpoints."},{"location":"alpha/#methods","title":"Methods","text":"Method Description train(X, y) Trains the Transformer model with early stopping based on validation loss. predict(X) Returns binary class predictions for the input data. predict_proba(X) Returns class probabilities for the input data. _preprocess_x(X) Reshapes and normalizes input data to match the sequence format required by the Transformer save_model() Saves the model checkpoint to the specified path. load_model() Loads the model checkpoint from the specified path."},{"location":"alpha/#xgboostmodel","title":"XGBoostModel","text":"<p>This is a wrapper around XGBoost\u2019s XGBClassifier, suitable for tabular classification problems.</p>"},{"location":"alpha/#parameters_1","title":"Parameters","text":"<p><code>**kwargs</code>: Any parameters accepted by <code>xgb.XGBClassifier</code>.</p>"},{"location":"alpha/#methods_1","title":"Methods","text":"Method Description train(X, y) -&gt; None Fits the XGBoost model using the input feature set and target variable. predict(X) -&gt; pd.Series Returns predicted labels for the input data. predict_proba(X) -&gt; pd.DataFrame Returns prediction probabilities for each class."},{"location":"alpha/#alphalogisticregression","title":"AlphaLogisticRegression","text":"<p>Initializes the logistic regression model and standard scaler.</p>"},{"location":"alpha/#methods_2","title":"Methods","text":"Method Description load_data() -&gt; pd.DataFrame Loads time-series alpha factor data from a CSV file. split_data(X, y, train_start_date, train_end_date, test_start_date, test_end_date) Splits the input data into training and testing sets using time windows. train_test_split(df, labels) Performs a traditional sklearn-style train-test split (not time-aware). preprocess(df) Preprocesses raw OHLCV data by computing log returns and removing price columns. generate_label(df) Generates binary labels from log_returns. feature_selection(X_train, y_train) Selects top 20 features using ANOVA F-test."},{"location":"datahandler/","title":"DataHandler","text":"<p>This module provides a structured, extensible way to retrieve, process, and cache financial and crypto market data from various sources. It consists of a base class <code>BaseDataHandler</code> and two specialized subclasses: <code>RegimeModelData</code> and <code>FinalAlphaModelData</code>.</p>"},{"location":"datahandler/#basedatahandler","title":"BaseDataHandler","text":"<p>Handles the core logic for fetching raw data from various APIs, applying preprocessing functions, and caching the results using <code>joblib</code> and <code>requests_cache</code>.  </p>"},{"location":"datahandler/#parameters","title":"Parameters","text":"Parameter Type Description symbol string Trading pair or asset (e.g., BTC) start_time datetime Start of data range (e.g., datetime(2024, 4, 17)). end_time datetime End of data range (e.g., datetime(2024, 4, 18)). window string Timeframe for data (e.g., 1d, 1h, 15m). limit (int, default=100000) Maximum number of rows to fetch. flatten (bool, default=True) If True, flattens nested JSON data when applicable."},{"location":"datahandler/#public-methods","title":"Public Methods","text":"<ul> <li><code>fetch_binance_data()</code>: Downloads OHLCV data from Binance via Cybotrade Datasource API. Automatically uses <code>requests_cache</code> to cache results.</li> <li><code>get_processed_data()</code>: Returns the processed pandas DataFrame.</li> <li><code>export(path: str, filename: str)</code>: Saves the processed data to a CSV file at the given path.</li> <li><code>load_from_disc(path: str)</code> : Loads raw data from a CSV file into the internal raw_data container.</li> </ul>"},{"location":"datahandler/#internal-methods","title":"Internal Methods","text":"<ul> <li><code>convert_to_unix_ms(dt: datetime)</code> : Converts a datetime object to a UNIX timestamp in milliseconds.</li> <li><code>_generate_cache_key()</code>: Returns a tuple used to identify cached results.</li> <li><code>_get_cache_key()</code>: Returns a string-formatted version of the cache key.</li> </ul>"},{"location":"datahandler/#example-usage","title":"Example Usage","text":"<pre><code>from backtesting.datahandler import BaseDataHandler\n\nbaseDataHandler = BaseDataHandler(symbol='BTC-USD',\n                      start_time=datetime(2025, 3, 1, tzinfo=timezone.utc),\n                      end_time=datetime(2025, 4, 1, tzinfo=timezone.utc),\n                      window=\"1h\")\n</code></pre>"},{"location":"datahandler/#regimemodeldata","title":"RegimeModelData","text":"<p>Custom data handler for regime classification models. Applies a series of volatility, trend, momentum, and volume-based indicators to compute regime shifts in market behavior.</p>"},{"location":"datahandler/#indicators","title":"Indicators","text":"Indicator Internal Method Description Log Return (inline in <code>preprocess</code>) Measures relative price change; used to standardize returns. Volatility (10) (inline in <code>preprocess</code>) Rolling standard deviation of log returns; used to assess price turbulence. Vol-Adj Return (inline in <code>preprocess</code>) Normalizes return by volatility; highlights abnormal movements. EMA (50, 200) compute_ema, compute_ema_200 Tracks price trend smoothness over short/long periods. RSI (14) compute_rsi Identifies overbought/oversold conditions. MACD + Signal compute_macd Detects trend reversals via moving average crossovers. ATR (14) compute_atr Measures price range volatility for risk analysis. SAR compute_sar Trend-following indicator showing potential reversals. Slope (14) compute_slope Measures directional rate of change. ADX (14) compute_adx Quantifies trend strength regardless of direction. OBV compute_obv_vectorized Measures volume flow to validate price trends."},{"location":"datahandler/#caching","title":"Caching","text":"<ul> <li>Loads from or saves to disk using <code>joblib</code> under <code>cache/processed/</code>.</li> <li>Automatically cleans up old cache files (older than 1 hour).</li> </ul>"},{"location":"datahandler/#public-methods_1","title":"Public Methods","text":"<p>Inherits all public methods from <code>BaseDataHandler</code>.</p>"},{"location":"datahandler/#example-usage_1","title":"Example Usage","text":"<pre><code>from backtesting.datahandler import RegimeModelData\n\nregimeModelData = RegimeModelData(symbol='BTC-USD',\n                      start_time=datetime(2025, 3, 1, tzinfo=timezone.utc),\n                      end_time=datetime(2025, 4, 1, tzinfo=timezone.utc),\n                      window=\"1h\")\n</code></pre>"},{"location":"datahandler/#logisticregressionmodeldata","title":"LogisticRegressionModelData","text":"<p>Specialized class for fetching multiple alpha-relevant features from Glassnode using the Cybotrade Datasource API. Data is compiled into a single DataFrame.</p>"},{"location":"datahandler/#indicators_1","title":"Indicators","text":""},{"location":"datahandler/#1-addresses","title":"1. Addresses","text":"Indicator Description min_10k_count Number of addresses holding at least 10,000 units of an asset. Indicates whale activity and market influence. min_100_count Number of addresses holding at least 100 units. Tracks retail accumulation. new_non_zero_count Number of new addresses with non-zero balance. Proxy for network growth and adoption. accumulation_count Addresses consistently accumulating more coins over time. Signals strong investor conviction. count Total number of addresses. General measure of network size. sopr Spent Output Profit Ratio. Ratio of price sold vs price paid for coins moved. Values &gt;1 indicate profit taking."},{"location":"datahandler/#2-blockchain","title":"2. Blockchain","text":"Indicator Description block_count Number of blocks mined. Indicates network liveness. utxo_created_count Number of unspent transaction outputs created. Reflects transaction activity and coin movement."},{"location":"datahandler/#3-distribution","title":"3. Distribution","text":"Indicator Description balance_exchanges Aggregate balance held on exchanges. Tracks potential sell-side liquidity and risk-on/risk-off sentiment."},{"location":"datahandler/#4-mining","title":"4. Mining","text":"Indicator Description hash_rate_mean Average hash rate over time. Proxy for network security and miner sentiment. revenue_from_fees Miner revenue from transaction fees. Reflects demand for block space. realized_loss Total value of coins moved at a lower price than they were acquired. Tracks panic selling. realized_profit Total value of coins moved at a higher price than acquisition. Indicates profit realization."},{"location":"datahandler/#5-indicators","title":"5. Indicators","text":"Indicator Description net_realized_profit_loss Difference between realized profit and loss. Signals net capital flows on-chain. net_unrealized_profit_loss Unrealized gains/losses across all held coins. Used to identify market euphoria or fear. liveliness Ratio of total coin days destroyed to total coin days created. Indicates HODLing behavior. nvt Network Value to Transactions ratio. Higher values suggest overvaluation relative to usage. nvts NVT Signal: smoothed version of NVT for better signal extraction. reserve_risk Risk/reward ratio based on HODL waves and price. Useful for long-term valuation. rhodl_ratio Combines age bands of coins to detect overheated or undervalued markets. seller_exhaustion_constant Measures when price and miner sell pressure are both low. Bullish reversal signal. stock_to_flow_deflection Deviation from S2F model. Gauges scarcity relative to issuance. velocity Rate of turnover of coins in the network. High values indicate economic activity."},{"location":"datahandler/#6-supply","title":"6. Supply","text":"Indicator Description active_more_1y_percent Percentage of coins unmoved for over 1 year. Indicates long-term holder conviction. inflation_rate Annualized increase in circulating supply. Important for monetary policy modeling. loss_sum Aggregate USD value of all coins currently in loss. Shows unrealized downside risk."},{"location":"datahandler/#7-transactions","title":"7. Transactions","text":"Indicator Description transfers_to_exchanges_count_pit Count of transactions sent to exchanges. Can indicate rising sell pressure. transfers_volume_to_exchanges_sum Total volume sent to exchanges. Tracks potential supply-side liquidity. transfers_volume_exchanges_net_pit Net transfer volume in/out of exchanges. Positive values indicate accumulation. transfers_volume_from_exchanges_mean_pit Average volume withdrawn from exchanges. High values indicate investor confidence. transfers_volume_from_exchanges_sum_pit Total volume withdrawn from exchanges. Measures HODLer behavior. transfers_from_exchanges_count_pit Number of withdrawal transactions. Correlates with exchange outflows. transfers_volume_entity_adjusted_sum_pit Total adjusted transfer volume across all entities. Filters internal transfers. transfers_volume_within_exchanges_sum_pit Volume moving between wallets within the same exchange. Tracks internal flow. transfers_volume_between_exchanges_sum_pit Volume moved between different exchanges. Reflects inter-exchange arbitrage and liquidity shift."},{"location":"datahandler/#public-methods_2","title":"Public Methods","text":"<ul> <li><code>fetch_all_endpoints()</code>: Aggregates data from all endpoints using common parameters and returns a single DataFrame.</li> </ul>"},{"location":"datahandler/#example-usage_2","title":"Example Usage","text":"<pre><code>from backtesting.datahandler import LogisticRegressionModelData\n\nlogisticRegressionModel = LogisticRegressionModelData(symbol='BTC-USD',\n                      start_time=datetime(2025, 3, 1, tzinfo=timezone.utc),\n                      end_time=datetime(2025, 4, 1, tzinfo=timezone.utc),\n                      window=\"1h\")\n</code></pre>"},{"location":"datahandler/#benchmarkdata","title":"BenchmarkData","text":"<p>A lightweight benchmark data handler designed to fetch historical closing price data from Yahoo Finance using the yfinance library. Primarily used to serve as a market benchmark (e.g., BTC/USD) for performance comparison in model backtesting.</p> Parameter Type Description symbol string Trading pair or asset (e.g., BTC-USD) start_time datetime Start of data range (e.g., datetime(2024, 4, 17)). end_time datetime End of data range (e.g., datetime(2024, 4, 18)). interval string Timeframe for data (e.g., 1m, 60m, 1d)"},{"location":"datahandler/#public-methods_3","title":"Public Methods","text":"<p><code>fetch_yfinance_data()</code> : Fetches benchmark price data for the given symbol and date range using yfinance.</p>"},{"location":"datahandler/#catching-strategy","title":"Catching Strategy","text":""},{"location":"datahandler/#requests_cache","title":"<code>requests_cache</code>","text":"<ul> <li>Caches raw API responses on disk to minimize duplicate requests.</li> <li>Useful for paginated and repetitive queries.</li> <li>Used in fetching OHLC</li> </ul>"},{"location":"datahandler/#joblib","title":"<code>joblib</code>","text":"<ul> <li>Caches processed DataFrames based on parameters (symbol, endpoint, start/end date, interval).</li> <li>Reduces recomputation for common queries.</li> </ul>"},{"location":"execution/","title":"Execution","text":"<p>This module handles how orders are executed, tracked, and converted into trades within a backtesting environment.</p>"},{"location":"execution/#brokerbase","title":"BrokerBase","text":"<p>Simulates a broker executing orders in a market environment using a success model and trading fees.</p>"},{"location":"execution/#attributes","title":"Attributes","text":"<ul> <li><code>trading_fee (float)</code>: Percentage-based trading fee (default: 0.0006 or 0.06%).</li> <li><code>execution_success_model (ExecutionSuccessModel)</code>: Determines whether an order is successfully executed.</li> </ul>"},{"location":"execution/#methods","title":"Methods","text":""},{"location":"execution/#execute_ordersorders-listorder-wallet-market_data-datetime-executes-a-list-of-orders-using-current-market-data-and-broker-logic","title":"<code>execute_orders(orders: list[Order], wallet, market_data, datetime)</code>: Executes a list of orders using current market data and broker logic.","text":"<ul> <li>Returns:    ```python   {     'executed_orders': [...],     'cancelled_orders': [...]   }</li> </ul> <p><code>execute_order(order: Order, wallet, market_data, datetime)</code>: Executes a single order based on the execution_success_model.</p> <ul> <li>Returns: <code>Order</code> object with updated status, executed_price, and executed_date_time.</li> </ul>"},{"location":"execution/#order","title":"Order","text":"<p>Represents a trade instruction with parameters like quantity, price, and signal direction.</p>"},{"location":"execution/#attributes_1","title":"Attributes","text":"<ul> <li><code>symbol (str)</code>: Asset symbol (e.g., BTCUSD).</li> <li><code>trading_signal (Signal)</code>: BUY or SELL signal.</li> <li><code>quantity (float</code>: Number of units to buy/sell.</li> <li><code>price_limit (float, optional)</code>: Optional price limit for limit orders.</li> <li><code>stop_loss_price (float, optional)</code>: Price to trigger a stop loss.</li> <li><code>desired_price (float, optional)</code>: Ideal execution price.</li> <li><code>execution_type (str)</code>: OPEN or CLOSE (default: OPEN).</li> <li><code>execution_interval (str)</code>: Timeframe granularity (e.g., HOUR).</li> <li><code>status (OrderStatus)</code>: PENDING, EXECUTED, or CANCELLED.</li> <li><code>executed_date_time (datetime)</code>: Timestamp of execution.</li> <li><code>executed_price (float)</code>: Price at which the order was filled.</li> </ul>"},{"location":"execution/#methods_1","title":"Methods","text":"<ul> <li><code>__str__()</code>: Returns a basic string summary of the order.</li> </ul>"},{"location":"execution/#trade","title":"Trade","text":"<p>Represents an actual position taken based on an executed order.</p>"},{"location":"execution/#attributes_2","title":"Attributes","text":"<ul> <li><code>symbol (str)</code>: Asset involved in the trade.</li> <li><code>entry_price (float)</code>: Price at which the trade was opened.</li> <li><code>entry_time (datetime)</code>: Timestamp of entry.</li> <li><code>quantity (float)</code>: Number of units traded.</li> <li><code>market_entry_type (str)</code>: LONG or SHORT.</li> <li><code>stop_loss_price (float)</code>: Stop loss trigger.</li> <li><code>exit_price (float, optional)</code>: Price at which trade closed.</li> <li><code>exit_time (datetime, optional)</code>: Timestamp of exit.</li> <li><code>profit (float)</code>: Target profit (not realized).</li> <li><code>status (TradeStatus)</code>: OPEN or CLOSED.</li> </ul>"},{"location":"execution/#methods_2","title":"Methods","text":"<ul> <li><code>__str__()</code>: Human-readable summary of the trade.</li> <li><code>@staticmethod create(order: Order, quantity: float = None) -&gt; Trade</code>: Creates a Trade instance from an executed Order.</li> </ul>"},{"location":"execution/#executionsuccessmodel","title":"ExecutionSuccessModel","text":"<p>Controls the logic for whether an order will successfully execute.</p>"},{"location":"execution/#attributes_3","title":"Attributes","text":"<ul> <li><code>sucess_rate (float)</code>: Probability of success (default is 1.0 = 100%).</li> </ul>"},{"location":"execution/#methods_3","title":"Methods","text":"<ul> <li><code>is_order_executed_successfully() -&gt; bool</code>: Returns whether the current order execution attempt is successful.</li> </ul>"},{"location":"execution/#execution-flow-summary","title":"Execution Flow Summary","text":"<ol> <li>Strategy generates pending Orders.</li> <li>BrokerBase.execute_orders receives these orders, applies fees, and determines execution success.</li> <li>Orders that succeed become Trades.</li> <li>PortfolioManager processes trades, updates equity, and tracks performance.</li> </ol>"},{"location":"performance/","title":"Performance","text":""},{"location":"performance/#performancemanager","title":"PerformanceManager","text":"<p>The <code>PerformanceManager</code> is the central component responsible for computing various performance metrics for a backtested trading strategy. It aggregates results from multiple submodules to provide both scalar and time-series metrics in a clean and structured format.</p> <p>To create an instance of the class:</p> <pre><code>from backtesting.performance.performance_manager import PerformanceManager\nperformanceManager = PerformanceManager(trades=trades, initial_capital=100)\n</code></pre>"},{"location":"performance/#parameters","title":"Parameters","text":"Parameter Type Description trades List(Dict) A list of executed trade records, each being a dictionary with trade information. initial_capital float The starting capital of the portfolio"},{"location":"performance/#methods","title":"Methods","text":"<p><code>get_metrics()</code> returns:</p> <ul> <li><code>scalar_metrics</code> (pd.DataFrame): A one-row dataframe containing scalar metrics, such as total return, Sharpe ratio, etc.</li> <li><code>time_series_metrics</code> (Dict): A dictionary of time series values for visualization (e.g., equity curve, drawdowns).</li> </ul>"},{"location":"performance/#performancebase","title":"PerformanceBase","text":"<p>The <code>PerformanceBase</code> class provides foundational calculations and data enrichment for performance analysis. It is initialized with a list of trade dictionaries and an initial capital value. The class appends transaction fees and computes the PnL (Profit and Loss) for each trade, forming the base data used by all metric calculators.</p>"},{"location":"performance/#parameters_1","title":"Parameters","text":"Parameter Type Description trades List(Dict) A list of executed trade records, each being a dictionary with trade information. initial_capital float The starting capital of the portfolio fee_rate Optional Transaction fee rate in percentage. Defaults to 0.06."},{"location":"performance/#methods_1","title":"Methods","text":"Method Description append_fee(rate, type=\"both\") Adds a \"fee\" field to each trade based on fee type append_pnl() Calculates the net PnL per trade, adjusted for direction and fees, and appends a \"pnl\" field."},{"location":"performance/#metric-types","title":"Metric Types","text":""},{"location":"performance/#1-trademetrics","title":"1. TradeMetrics","text":"<p>The TradeMetrics submodule is responsible for analyzing trade-level statistics, providing insights into the quality and characteristics of individual trades.</p>"},{"location":"performance/#metrics","title":"Metrics","text":"Metric Description total_trades Total number of trades executed. win_rate Proportion of profitable trades. loss_rate Proportion of unprofitable (losing) trades. average_win Mean profit for winning trades. average_loss Mean loss for losing trades. holding_period_mean Average duration (in time units) a position was held. holding_period_median Median duration a position was held. holding_period_max Longest duration a single trade was held. holding_period_min Shortest duration a single trade was held. profit_factor Ratio of gross profit to gross loss."},{"location":"performance/#methods_2","title":"Methods","text":"<p><code>calculate_all()</code> calculates and returns all above metrics.</p>"},{"location":"performance/#2-timeseriesmetrics","title":"2. TimeSeriesMetrics","text":""},{"location":"performance/#metrics_1","title":"Metrics","text":""},{"location":"performance/#time-series","title":"Time Series","text":"Metric Description equity_curve Dictionary of daily equity values over the backtesting period. daily_returns Daily return as a percentage change in equity."},{"location":"performance/#scalar","title":"Scalar","text":"Metric Description cumulative_return Overall return from the strategy over the full trading period. max_drawdown Largest observed drop from a peak to a trough in the equity curve. volatility Standard deviation of daily returns, representing the risk or variability. annualized_volatility Daily volatility scaled by \u221a252 to reflect annualized risk."},{"location":"performance/#methods_3","title":"Methods","text":"<p><code>calculate_all()</code> calculates and returns all above metrics.</p>"},{"location":"performance/#3-riskmetrics","title":"3. RiskMetrics","text":""},{"location":"performance/#metrics_2","title":"Metrics","text":"Metric Description sharpe_ratio Sharpe ratio using daily returns: excess return over standard deviation. annualized_sharpe_ratio Sharpe ratio annualized over 252 trading days. sortino_ratio Sortino ratio using downside deviation instead of total standard deviation. annualized_sortino_ratio Annualized Sortino ratio over 252 trading days. calmar_ratio Calmar ratio: annualized return divided by maximum drawdown."},{"location":"performance/#methods_4","title":"Methods","text":"<p><code>calculate_all()</code> calculates and returns all above metrics.</p>"},{"location":"portfolio/","title":"Portfolio","text":"<p>This module provides classes to manage trades, track performance, and evaluate strategies in a backtesting engine.</p>"},{"location":"portfolio/#portfolio","title":"Portfolio","text":"<p>Handles tracking and management of trading activities and account status during backtesting.</p>"},{"location":"portfolio/#attributes","title":"Attributes","text":"<ul> <li><code>wallet</code>: Current cash in the portfolio.</li> <li><code>holdings</code>: Asset units currently held.</li> <li><code>equity</code>: Total value of wallet + holdings.</li> <li><code>initial_capital</code>: Starting capital.</li> <li><code>investment_rate</code>: Portion of capital allocated per trade.</li> <li><code>shorting_preference</code>: Placeholder for future shorting strategy logic.</li> <li><code>pending_orders</code>, <code>executed_orders</code>, <code>cancelled_orders</code>: Lists to track orders at various stages.</li> <li><code>open_trades</code>, <code>closed_trades</code>: Lists to track trade lifecycle.</li> <li><code>positions</code>: Stores position history.</li> <li><code>performance</code>: Placeholder for performance metrics.</li> <li><code>max_equity</code>: Peak equity for drawdown calculation.</li> <li><code>total_signal</code>, <code>total_trading_signal</code>: For signal frequency analysis.</li> </ul>"},{"location":"portfolio/#key-methods","title":"Key Methods","text":"<ul> <li><code>get_equity_value(market_price=0.0)</code>: Calculates current equity based on market price.</li> <li><code>has_open_trades(market_entry_type=None)</code>: Checks for active trades (optionally by type).</li> <li><code>add_pending_order(order)</code>, <code>add_executed_order(order)</code>, <code>add_cancelled_order(order)</code>: Adds single orders.</li> <li><code>add_open_trade(trade)</code>, <code>add_closed_trade(trade)</code>: Adds trades.</li> <li><code>add_executed_orders(list[Order])</code>, <code>add_cancelled_orders(list[Order])</code>: Adds bulk orders.</li> <li><code>get_pending_orders()</code>, <code>get_executed_orders()</code>, <code>get_open_trades()</code>, <code>get_closed_trades()</code>: Accessors for trade state.</li> <li><code>get_all_trades()</code>: Returns all open and closed trades.</li> <li><code>overview()</code>: Prints a summary of the portfolio status.</li> </ul>"},{"location":"portfolio/#portfoliomanager","title":"PortfolioManager","text":"<p>Handles execution flow, trade tracking, position management, and performance analytics.</p>"},{"location":"portfolio/#attributes_1","title":"Attributes","text":"<ul> <li><code>portfolio</code>: Instance of the <code>Portfolio</code> class.</li> </ul>"},{"location":"portfolio/#key-methods_1","title":"Key Methods","text":"<ul> <li><code>generate_order(symbol, trading_signal, current_market_data)</code>: Generates a pending order.</li> <li><code>send_pending_orders()</code>: Returns and clears all pending orders.</li> <li><code>update_orders(orders)</code>: Updates wallet and holdings based on executed or cancelled orders.</li> <li><code>update_trades(executed_orders)</code>: Closes or creates new trades from order list.</li> <li><code>update_portfolio(previous_data, current_data)</code>: Updates portfolio state (position, PnL, drawdown, equity).</li> <li><code>export_closed_trades()</code>: Returns closed trades in a structured exportable format.</li> <li><code>get_max_drawdown()</code>: Returns maximum drawdown observed during backtest.</li> <li><code>calculate_sharpe_ratio(periods_per_year=252, risk_free_rate=0.0)</code>: Calculates Sharpe Ratio based on equity curve.</li> </ul>"},{"location":"portfolio/#position-class","title":"Position Class","text":"<p>Represents the state of a single position in the portfolio.</p>"},{"location":"portfolio/#attributes_2","title":"Attributes","text":"<ul> <li><code>direction</code>: Direction of trade (1 = long, -1 = short, 0 = neutral).</li> <li><code>size</code>: Quantity of asset held.</li> <li><code>pnl</code>: Profit or loss for the position.</li> <li><code>equity</code>: Portfolio equity at that moment.</li> <li><code>drawdown</code>: Equity drawdown from the historical peak.</li> </ul>"},{"location":"portfolio/#methods","title":"Methods","text":"<ul> <li><code>__str__()</code>: Returns string summary of the position\u2019s details.</li> </ul>"},{"location":"regime/","title":"RegimeDetectionModel","text":""},{"location":"regime/#marketregimehmm","title":"MarketRegimeHMM","text":"<p>A class to identify market regimes using a Gaussian Hidden Markov Model (HMM). This tool is especially useful for detecting patterns in financial time series, labeling different market conditions like bull, bear, and neutral regimes.</p>"},{"location":"regime/#marketregimehmm-class","title":"<code>MarketRegimeHMM()</code> Class","text":""},{"location":"regime/#parameters","title":"Parameters","text":"<ul> <li>n_states (int): Number of hidden states (regimes) for the HMM.</li> <li>features (list): List of column names used as features for modeling.</li> <li>covariance_type (str): Type of covariance ('full', 'diag', etc.) for the HMM.</li> <li>n_iter (int): Maximum number of iterations during model training.</li> <li>tol (float): Convergence threshold.</li> <li>model_path_prefix (str): Optional prefix for saving/loading models.</li> </ul>"},{"location":"regime/#methods","title":"Methods","text":"Method Description load_and_prepare_data(path) Loads and formats a CSV file. fit(df) Fits the HMM on the specified features in the DataFrame. predict(df) Predict regimes using the trained model. smooth_regime(df, window=7) Applies rolling mode to smooth the regime predictions. compute_blocks(df) Identifies distinct regime blocks and changes. label_regimes(df) Labels each smoothed regime based on average return and volatility. save(model_path_prefix=None) Saves the trained HMM model and the associated scaler using joblib. load() Loads a previously saved HMM model and scaler from disk. tune_hyperparameters(df, param_grid=None, cv=5, scoring='neg_log_likelihood') Performs hyperparameter tuning using Grid Search with time-series cross-validation. save_best_params(best_params, config_file='config.py') This method updates a configuration file (config.py) with the best hyperparameters found during model tuning, such as the number of HMM states or iteration count. This allows reproducibility and consistency across experiments by persisting optimal parameter values. plot_price_with_regime(df) This method visualizes the price trend of an asset alongside its detected market regimes (bull, bear, or neutral). It uses color-coded background shading to indicate different regimes over time."},{"location":"sentiment/","title":"Sentiment","text":""},{"location":"sentiment/#sentiment-analysis-model","title":"Sentiment Analysis Model","text":""},{"location":"sentiment/#retrieving-data","title":"Retrieving data","text":""},{"location":"sentiment/#news-articles","title":"News Articles","text":""},{"location":"sentiment/#newsapi-class","title":"<code>NewsAPI()</code> Class","text":"<p>The <code>NewsAPI</code> class retrieves news articles based on a query from NewsAPI. This API allows you to access news articles based on specified criteria such as keywords, dates, and sorting options. For more information, refer to the NewsAPI - NewsAPI Official documentation.</p>"},{"location":"sentiment/#methods","title":"Methods","text":"<p><code>get_news(query,fromTimeFrame, toTimeFrame, sortBy=\"popularity\", language=\"en\")</code></p> <p>Parameters:</p> <ul> <li>query (str): The search query (e.g., \"bitcoin\").</li> <li>fromTimeFrame (str): The start time for the search in YYYY-MM-DDTHH:MM:SS format.</li> <li>toTimeFrame (str): The end time for the search in YYYY-MM-DDTHH:MM:SS format.</li> <li>sortBy (str): Sort the results by popularity or other metrics (default is \"popularity\").</li> <li>language (str): The language of the articles (default is \"en\").</li> </ul> <p>Returns a list of dictionaries containing information about the articles (e.g., crypto, text, and published date).</p>"},{"location":"sentiment/#social-media-posts","title":"Social Media Posts","text":""},{"location":"sentiment/#tweepyapi-class","title":"<code>TweepyAPI()</code> Class","text":"<p>The TweepyAPI class retrieves tweets from Twitter API v2 via Tweepy. It allows you to fetch posts containing specific keywords or hashtags from Twitter. The class supports filtering by language and time frame, as well as excluding retweets for cleaner data. For more details, check the Tweepy: Twitter API v2 - Tweepy Official documentation.</p>"},{"location":"sentiment/#methods_1","title":"Methods","text":"<p><code>get_tweets(query, fromTimeFrame, toTimeFrame, max_tweets=100, lang=\"en\")</code></p> <p>Parameters:</p> <ul> <li>query (str): The search query (e.g., \"bitcoin OR BTC\"). You can also include operators like lang:{language} to filter by language.</li> <li>fromTimeFrame (str): The start time for the search in YYYY-MM-DDTHH:MM:SS format.</li> <li>toTimeFrame (str): The end time for the search in YYYY-MM-DDTHH:MM:SS format.</li> <li>max_tweets (int): The maximum number of tweets to retrieve (default is 100).</li> <li>lang (str): The language of the tweets (default is \"en\").</li> </ul> <p>This method retrieves tweets from Twitter within the specified query, time frame, and language. It supports pagination for fetching a large number of tweets and excludes retweets.</p>"},{"location":"sentiment/#preprocessing-data","title":"Preprocessing data","text":""},{"location":"sentiment/#methods_2","title":"Methods","text":"Method Description reformatDate(data) Ensures all dates are in ISO 8601 format and UTC (YYYY-MM-DDTHH:MM:SSZ). cleanNewsText(data) Performs extra cleaning specific to news article titles (e.g., removes publisher tags, ellipses). cleanSMPostsText(data) Performs extra cleaning specific to social media posts (e.g., removes mentions, hashtags, emojis). cleanAllText(data) General text cleaning for all data (e.g., lowercasing, removing URLs, HTML tags, and special characters). mergeCleanedData(data1, data2) Merges two datasets into one."},{"location":"sentiment/#analyse-sentiment","title":"Analyse sentiment","text":"<p>Loads a pretrained model from HuggingFace and perform sentiment analysis. For more information, refer to CryptoBert.</p>"},{"location":"sentiment/#method","title":"Method","text":"<p><code>classify_sentiment(texts)</code></p> <p>Parameter:</p> <ul> <li>texts: Processed texts that is ready to fit into model for sentiment analysis</li> </ul> <p>Returns the sentiment label and score of the input text.</p>"},{"location":"strategy/","title":"Strategy","text":""},{"location":"strategy/#strategy","title":"Strategy","text":"<p>The <code>strategy</code> module defines the framework for trading strategies used in the backtesting system. It contains a <code>StrategyBase</code> class that all strategies should inherit from and implement their own trading signal logic.</p>"},{"location":"strategy/#strategybase-class","title":"<code>StrategyBase()</code> Class","text":"<p>An abstract base class for all trading strategies. All custom strategies should inherit from this class and override the <code>generate_trading_signal</code> method.</p>"},{"location":"strategy/#parameter","title":"Parameter","text":"<ul> <li><code>df_historical_data (pd.DataFrame, optional)</code>: Historical price data used for strategy computation.</li> </ul>"},{"location":"strategy/#methods","title":"Methods","text":"<p><code>generate_trading_signal(data, datetime=None, index=0)</code> To be implemented by subclasses. Returns one of the values in <code>Signal</code> enum:</p> <ul> <li><code>Signal.BUY (1)</code></li> <li><code>Signal.SELL (-1)</code></li> <li><code>Signal.HOLD (0)</code></li> </ul>"},{"location":"strategy/#buyandholdstrategy-class","title":"<code>BuyAndHoldStrategy()</code> Class","text":"<p>A simple strategy that issues a single buy signal on the first execution and holds the position forever.</p>"},{"location":"strategy/#momentumstrategy-class","title":"<code>MomentumStrategy()</code> Class","text":"<p>Calculates average momentum over a specified window.</p> <ul> <li>Buys if <code>momentum</code> &gt; 0</li> <li>Sells if <code>momentum</code> &lt; 0</li> <li>Holds if <code>momentum</code> = 0 or not available</li> </ul>"},{"location":"strategy/#parameters","title":"Parameters","text":"Parameter Type Description df_historical_data dataframe DataFrame with at least a 'close' column. window int Look-back period for momentum calculation."},{"location":"strategy/#movingaveragecrossoverstrategy-class","title":"<code>MovingAverageCrossoverStrategy()</code> Class","text":"<p>Implements a moving average crossover strategy.</p> <ul> <li>Buys when <code>SMA</code> &gt; <code>LMA</code></li> <li>Sells when <code>LMA</code> &gt; <code>SMA</code></li> <li>Holds when equal or not available</li> </ul>"},{"location":"strategy/#parameters_1","title":"Parameters","text":"Parameter Type Description short_window Optional Period for short-term moving average. long_window Optional Period for long-term moving average."},{"location":"strategy/#samplestrategy-class","title":"<code>SampleStrategy()</code> Class","text":"<p>A toy/sample strategy integrating a custom FinalAlphaModel. Currently, issues a buy signal if the closing price is below 60, else sells.</p> <p>Notes:</p> <ol> <li>All strategies must return a signal from the <code>Signal</code> enum: <code>BUY</code>, <code>SELL</code>, or <code>HOLD</code>.</li> <li><code>data</code> is assumed to be a dictionary or record of relevant market data for a given time step.</li> <li><code>datetime</code> is used to index into precomputed historical indicators.</li> </ol>"},{"location":"visualisation/","title":"Visualisation","text":""},{"location":"visualisation/#visualisation","title":"Visualisation","text":"<p>The <code>Visualisation</code> class is responsible for generating and displaying various performance-related charts and metrics for a backtested trading strategy. It integrates with the PerformanceManager to visualize the strategy's performance, including the equity curve, daily returns, performance metrics, and price chart.</p> <p>To create an instance of the class:</p> <pre><code>from backtesting.visualisation.visualisation import StrategyVisualisation\nstrategyVisualiser = StrategyVisualisation(performance_data, performance_metrics, market_data)\n</code></pre>"},{"location":"visualisation/#parameters","title":"Parameters","text":"Parameter Type Description performance_data dict[str, dict[str, list]] A dictionary where each key is a strategy name and the value is a dictionary with keys like 'datetimes', 'equity_values', and 'daily_returns'. performance_metrics pd.DataFrame or pd.Series A set of scalar performance metrics (e.g., Sharpe ratio, max drawdown) to be displayed in a summary table. market_data pd.DataFrame A DataFrame containing market data with columns such as 'datetime', 'open', 'high', 'low', and 'close'. This data will be used to plot the charts."},{"location":"visualisation/#methods","title":"Methods","text":"Method Description plot_equity_curve(self, title=\"Equity Curve\") Plots the equity curve for each strategy in the performance_data. tabulate_metrics(self, title=\"Performance Metrics Summary\") Creates a table displaying the performance metrics for the strategy. plot_daily_returns(self, title=\"Daily Returns\") Plots the daily returns for each strategy in the performance_data. plot_price(self, title=\"Price Chart\", with_signals=True) Plots the price chart along with buy and sell signals. plot(self, all=True, charts=None) Plots the requested charts either all at once or a specific set of charts. export(self, format=\"html\", all=True, charts=None, export_dir=\"exports\") Exports the charts in the specified format to the specified directory."},{"location":"visualisation/#comparisonplot","title":"ComparisonPlot","text":"<p>The <code>ComparisonPlot</code> class provides a suite of interactive charts using Plotly for comparing the performance of multiple backtesting strategies.</p>"},{"location":"visualisation/#parameters_1","title":"Parameters","text":"Parameter Type Description performances_data dict[str, pd.DataFrame] Dictionary where keys are strategy names and values are DataFrames with columns datetimes, equity_values, daily_returns. performances_metrics dict[str, dict[str, float]] Dictionary mapping strategy names to their corresponding performance metric dictionary."},{"location":"visualisation/#methods_1","title":"Methods","text":"Method Description plot_comparison_equity_curve(title=\"Comparison Equity Curve\", plot_overlapping_only=True) Generates an interactive equity curve line chart for each strategy. comparison_metrics_table(title=\"Comparison Performance Metrics\") Displays a table comparing performance metrics across strategies. plot_comparison_daily_returns(title=\"Comparison Daily Returns\", plot_overlapping_only=True) Generates a line chart showing daily returns for each strategy. plot(all=True, charts=None) Generates charts for either all or a specific list of supported chart types. export(format=\"html\", all=True, charts=None, export_dir=\"exports\") Exports charts to files in the specified format."}]}